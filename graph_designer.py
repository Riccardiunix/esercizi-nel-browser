import os
import ruamel.yaml

import graphml_converter
GENERATED_DIRECTORY = os.path.join(os.getcwd(),"esame","generated")
TEMPLATES_DIRECTORY = os.path.join(os.getcwd(),"esame","templates","esame")

v = graphml_converter.node_edges()
e = graphml_converter.node_arrow()

nodes_positions = {}
numero_nodi, numero_archi = graphml_converter.numero_node_edges()
coordinate_nodi = []
coordinate_nodi = graphml_converter.node_position()

def assign_coords(v):
    for node,count in zip(v,range(numero_nodi)):
        nodes_positions[node] = {}
        nodes_positions[node]['x'] = coordinate_nodi[count][0]
        nodes_positions[node]['y'] = coordinate_nodi[count][1]

def write_yaml():
    yaml = ruamel.yaml.YAML()
    graph_edges = graphml_converter.edge_string() #grafo senza l'informazione arco puntato o meno
    with open('simulazione_esame/esercizio_3/modo_browser/dp_mst.yaml') as fp:
        data = yaml.load(fp)
    
    data['instance']['n'] = numero_nodi
    data['instance']['m'] = numero_archi
    data['instance']['edges'] = graph_edges
        
    with open('simulazione_esame/esercizio_3/modo_browser/dp_mst.yaml', 'w') as fp:        
        yaml.dump(data, fp) 

def init_graph_html():
    assign_coords(v)
    txt = ""
    for node in v:
        txt += f"<div class='node' id='{node}' style='top:{nodes_positions[node]['y']+60}%;left:{nodes_positions[node]['x']+4}%; background: green;' ondblclick='javascript:change(this.id);'>{node}</div>\n"
    txt += "<script>\n"
    txt += "  $('.node').draggable();\n"      
    txt += "  var _lines = new Array(); //This array will store all lines (option)\n"
    txt += "  var _canvas = document.createElement('canvas');\n"
    txt += "  var _ctx;\n"
    txt += "  var ele1 , ele2, f=0;\n"
    txt += "  var lineindex =0;\n"
    txt += "  var linemap = {};\n"
    txt += "  var _left = new Object(); //This will store _left elements offset\n"
    txt += "  var _right = new Object(); //This will store _right elements offset\n"
    txt += "  var _color='coral';\n"
    txt += "  var _dash;\n"
    txt += "  var _id;\n"
    txt += "  var clientrectleft\n"
    txt += "  var clientrectright\n"
    txt += "  var leftnodeoffsetx\n"
    txt += "  var leftnodeoffsety\n"
    txt += "  var rightnodeoffsetx\n" 
    txt += "  var rightnodeoffsety\n" 
    txt += "  var dax\n" 
    txt += "  var day\n" 
    txt += "  var dangle\n"
    txt += "  var rightx\n" 
    txt += "  var righty\n"  
    txt += "  var leftx\n"
    txt += "  var lefty\n"
    txt += "  var _error =false;\n"
    txt += "    var connect = function() {\n"
    txt += "      var _me = this;\n"
    txt += "      //Initialize Canvas object\n"
    txt += "      _canvas.id = 'cav1';\n"
    txt += "      _canvas.width = document.body.clientWidth;\n"
    txt += "      _canvas.height = document.body.clientHeight;\n"
    txt += "      document.body.appendChild(_canvas)\n"
    txt += "      _ctx = _canvas.getContext('2d');\n"
    txt += "      this.drawLine = function(option) {\n"
    txt += "        //It will push line to array.\n"
    txt += "        linemap[`${option.left_node}${option.right_node}`] = _lines.length;\n"
    txt += "        _lines.push(option);\n"
    txt += "        this.connect(option);\n"    
    txt += "      };\n"
    txt += "  this.kruskalize =function (_cl = 'rgb(0,0,0,0.08)')  {\n"
    txt += "    for ( line of _lines) {\n"
    txt += "      line.col = _cl;\n"
    txt += "    }\n"
    txt += "  }\n"
    txt += "      this.changecolor = function (starting , ending , assignedcolor) {\n"
    txt += "    if (linemap[`${starting}${ending}`] != undefined)  {\n"
    txt += "       let  targg = parseInt(linemap[`${starting}${ending}`]);\n"
    txt += "       console.log(targg , starting , ending  , assignedcolor)\n"
    txt += "      _lines[targg].col =assignedcolor;\n"
    txt += "    }\n"
    txt += "    else {\n"
    txt += "      let targg = parseInt(linemap[`${ending}${starting}`]);\n"
    txt += "      console.log(targg , starting , ending  , assignedcolor)\n"
    txt += "      _lines[targg].col =assignedcolor;\n"
    txt += "    }\n"
    txt += "      this.redrawLines();\n"
    txt += "      }\n"
    txt += "      this.dl = function(one , two) {\n"
    txt += "        for (var y = 0 ; y < _lines.length ; ++y) {\n"
    txt += "   if ((_lines[y].left_node) == one &&  (_lines[y].right_node) == two) {\n"
    txt += "    _lines.splice(y,1);\n"
    txt += "   }\n"
    txt += "        }\n"   
    txt += "      };\n"
    txt += "      //This Function is used to connect two different div with a dotted line.\n"
    txt += "     this.connect = async function(option) {\n"
    txt += "      if ( option.left_node == undefined || option.left_node == 'null' || option.right_node == undefined || option.right_node == 'null'  ) {\n"
    txt += "        return;\n"
    txt += "      }\n"
    txt += "            //To decide colour of the line\n"   
    txt += "                _color = option.col || 'coral';\n"                
    txt += "                _ctx.font = '30px Segoe UI';\n"
    txt += "            //To decide style of the line. dotted or solid\n"
    txt += "            switch (option.style) {\n"
    txt += "              case 'dashed':\n"
    txt += "                _dash = [4, 2];\n"
    txt += "                break;\n"
    txt += "              case 'solid':\n"
    txt += "                _dash = [0, 0];\n"
    txt += "                break;\n"
    txt += "              case 'dotted':\n"
    txt += "                _dash = [2, 2];\n"
    txt += "                break;\n"
    txt += "              default:\n"
    txt += "                _dash = [0, 0];\n"
    txt += "                break;\n"
    txt += "            }\n"
    txt += "            _ctx.setLineDash(_dash);\n"
    txt += "            //If left_node is actually right side, following code will switch elements.\n"
    txt += "               _left_node = document.getElementById(option.left_node);\n"
    txt += "               _right_node = document.getElementById(option.right_node);\n"
    txt += "               if (_left_node == null || _right_node == null) {return;}\n"
    txt += "               clientrectleft = _left_node.getBoundingClientRect();\n"
    txt += "               clientrectright = _right_node.getBoundingClientRect();\n"
    txt += "               leftnodeoffsetx = clientrectleft.left +document.documentElement.scrollLeft;\n"
    txt += "               leftnodeoffsety = clientrectleft.top +document.documentElement.scrollTop;\n"
    txt += "               rightnodeoffsetx = clientrectright.left +document.documentElement.scrollLeft;\n"
    txt += "               rightnodeoffsety = clientrectright.top +document.documentElement.scrollTop;\n"
    txt += "               dax = (rightnodeoffsetx+ _right_node.offsetHeight/2) - (leftnodeoffsetx+ _left_node.offsetWidth/2);\n"
    txt += "               day = (rightnodeoffsety+ _right_node.offsetHeight/2) - (leftnodeoffsety+ _left_node.offsetHeight/2);\n"
    txt += "               dangle = Math.atan2(day ,dax);\n"
    txt += "               rightx = (_right_node.offsetWidth/2) * Math.cos(135+dangle) + (rightnodeoffsetx+ _right_node.offsetWidth/2) ;\n"
    txt += "               righty  = (_right_node.offsetHeight/2) * Math.sin(135+dangle) + (rightnodeoffsety + (_right_node.offsetHeight / 2)) ;\n"
    txt += "               leftx = (_left_node.offsetWidth/2) * Math.cos(.05+dangle) + (leftnodeoffsetx+ _left_node.offsetWidth/2) ;\n"
    txt += "               lefty  = (_left_node.offsetHeight/2) * Math.sin(.05+dangle) + (leftnodeoffsety + (_left_node.offsetHeight / 2)) ;\n"
    txt += "              //Get Left point and Right Point\n"
    txt += "              _left.x = leftx\n"
    txt += "              _left.y = lefty\n"
    txt += "              _right.x = rightx\n"
    txt += "              _right.y = righty\n"
    txt += "                ele1_x = _left.x;\n"
    txt += "                ele1_y = _left.y;\n"
    txt += "                ele2_x = _right.x;\n"
    txt += "                ele2_y = _right.y;\n"
    txt += "                if (option.text == undefined) {\n"
    txt += "                  option.text = ''\n"
    txt += "                }\n"
    txt += "                _ctx.beginPath(); \n"             
    txt += "              _ctx.moveTo(_left.x, _left.y );\n"     
    txt += "              _ctx.lineTo((_right.x), (_right.y));\n"              
    txt += "              _ctx.lineWidth = option.width || 2;\n"
    txt += "              _ctx.strokeStyle = _color;\n"
    txt += "     if (option.gtype == 'arrow') {\n"
    txt += "              let headlen = 16; // length of head in pixels\n"
    txt += "              var dx = Number(ele2_x) - Number(ele1_x);\n"
    txt += "              let dy = ele2_y - ele1_y;\n"
    txt += "              let angle = Math.atan2(dy, dx);\n"
    txt += "              _ctx.moveTo( ele1_x,  ele1_y);\n"
    txt += "              _ctx.lineTo(ele2_x, ele2_y);\n"
    txt += "              _ctx.lineTo(ele2_x - headlen * Math.cos(angle - Math.PI / 6),  ele2_y - headlen * Math.sin(angle - Math.PI / 6));\n"
    txt += "              _ctx.moveTo(ele2_x,  ele2_y);\n"
    txt += "              _ctx.lineTo(ele2_x - headlen * Math.cos(angle + Math.PI / 6),  ele2_y - headlen * Math.sin(angle + Math.PI / 6));\n"    
    txt += "            }\n"
    txt += "              _ctx.stroke();\n"             
    txt += "  f = 0;\n"
    txt += "              _ctx.font = 'bold 1.6em Segoe ui';\n"
    txt += "              _ctx.fillText(option.text,(_right.x +_left.x)/2-15 ,( _right.y + _left.y)/2-15);\n"
    txt += "            //option.resize = option.resize || false;\n"     
    txt += "        }\n" 
    txt += "      window.addEventListener('resize',function()  {\n"           
    txt += "          _me.redrawLines();\n"
    txt += "        //_me.Blines();\n"
    txt += "       //  _me.Listlines();\n"
    txt += "      })\n"
    txt += "      this.redrawLines = async function() {\n"
    txt += "        if (_lines.length == 0) return;\n"    
    txt += "        _ctx.clearRect(0, 0,  10000, 4300);\n"
    txt += "          for (let li = 0 ; li < _lines.length ;li++) {\n"          
    txt += "            _me.connect(_lines[li])\n"    
    txt += "            }\n"            
    txt += "      };\n"
    txt += "      this.Splaylines = async function() {\n"
    txt += "        if (tree.length == 0) return;\n"
    txt += "        _ctx.clearRect(0, 0,  10000, 4300);\n"
    txt += "        for (let source in tree) {\n"
    txt += "          let destination = tree[source];\n"
    txt += "          if(destination != 'null')\n"
    txt += "          _me.connect({left_node:source , right_node:destination+'treetop'})\n"
    txt += "          }\n"
    txt += "      };\n"
    txt += "      this.Listlines = function() {\n"
    txt += "        if (next.length == 0) return;\n"
    txt += "       _ctx.clearRect(0, 0,  10000, 4300);\n"
    txt += "        for (let source in next) {\n"
    txt += "          let destination = next[source];\n"
    txt += "          if(destination != 'null')\n"
    txt += "          _me.connect({left_node:source , right_node:destination , col:'black' ,style:'dashed'})\n"
    txt += "          }\n"
    txt += "      };\n"
    txt += "      this.Blines = function() {\n"
    txt += "        if (BTree.length == 0) return;\n"
    txt += "        _ctx.clearRect(0, 0,  10000, 4300);\n"
    txt += "        for (let source in BTree) {\n"
    txt += "          let destination = BTree[source];\n"
    txt += "          if(destination != 'null')\n"
    txt += "          _me.connect({left_node:source , right_node:destination+'top',gtype:'UD' })\n"
    txt += "          }\n"
    txt += "      };\n"
    txt += "      return this;\n"
    txt += "    };\n"
    txt += "    var LineController = connect();\n"
    for edge in e:
        txt += "  LineController.drawLine({\n"
        txt += f"    left_node:'{edge[0]}',\n"
        txt += f"    right_node:'{edge[1]}',\n"
        txt += f"    col: 'black',\n"
        txt += f"    width: 2,\n"
#       txt += f"    text: {edge[2]},\n"
        txt += f"    style: 'solid',\n"
        txt += f"    gtype: '{edge[2]}',\n"
        txt += "  })\n"
        txt += f"  $( '.'+'node' ).draggable({{\n"
        txt += "  scroll: false,\n"
        txt += f"  drag: function(event, ui){{LineController.redrawLines();}}\n"
        txt += "  });\n"

    txt +=f"    var counters = Array(256).fill(0);\n"
    txt +="     var isPath = false;\n"
    txt +="     var path = Array();\n\n"
    txt += f"  function change(id) {{\n"
    txt += "    var colors = ['red', 'orange', 'blue', 'green'];\n"
    txt += "    var len = colors.length;\n"
    txt += f"   var e = document.getElementById(id);\n"
    txt += "    var index = id.charCodeAt(0);\n"
    txt += "    var counter = counters[index];\n"
    txt += f"    if (counter != len) {{\n"
    txt += f"      e.style.background = colors[counter];\n"
    txt += f"      counter = counter + 1;\n"
    txt += "    } else {\n"
    txt += f"      counter = 0;\n"
    txt += f"      e.style.background = colors[counter];\n"
    txt += "    }\n"   
    txt += "    counters[index] = counter;\n"
    txt += "    if(isPath){\n"
    txt += "        path.push(id);\n"
    txt += "    }\n"
    txt += "  }\n"
    txt += "    //Modalità attivata\n"
    txt += "    function path_color(){\n"
    txt += "        isPath = !isPath;\n"
    txt += "        if(isPath == true){\n"
    txt += "            path = []; //resetto il percorso\n"
    txt += "            refresh_nodes('green'); //resetto colore grafo\n"
    txt += "            alert('Select a path by coloring nodes');\n"
    txt += "        }\n"
    txt += "        else{\n"
    txt += "            if(Object.keys(path).length <= 1)\n"
    txt += "                alert('Path not valid!');   //Perorso con un solo nodo non valido\n"
    txt += "            else{\n"
    txt += "                for(i=1; i < Object.keys(path).length; i++){\n"
    txt += "                    a = path[i-1];\n"
    txt += "                    b = path[i];\n"
    txt += "                    changecolor(a,b, 'red');\n"
    txt += "                    document.getElementById(a).style.background = 'green';\n"
    txt += "                    document.getElementById(b).style.background = 'green';\n"
    txt += "                }\n"
    txt += "            }\n"
    txt += "        }\n"
    txt += "    }\n\n"
    txt += "    //Colora l'intero grafo\n"
    txt += "    function refresh_nodes(color){\n"
    txt += "        var divs = document.getElementsByClassName('node');\n"
    txt += "        for(i=0; i<Object.keys(divs).length; i++){\n"
    txt += "            id = divs[i].id;\n"
    txt += "            index = id.charCodeAt(0);\n"
    txt += "            counters[index] = 0;\n"
    txt += "            divs[i].style.background = color\n"
    txt += "        }\n"
    txt += "    }\n\n"
    txt += "    //Colora l'intero grafo\n"
    txt += "    function refresh_edges(){\n"
    txt += "        for(i=1; i < Object.keys(_lines).length; i++){\n"
    txt += "            a = _lines[i].left_node;\n"
    txt += "            b = _lines[i].right_node;\n"
    txt += "            changecolor(a,b, 'black');\n"
    txt += "        }\n"
    txt += "    }\n\n"
    txt += "    function send_output(){\n"
    txt += "        var output = new Object();\n"
    txt += "        var nodes = document.getElementsByClassName('node');\n"
    txt += "        output.n = new Array();\n"
    txt += "        //Aggiungo nodi all'output\n"
    txt += "        for(i=0; i<Object.keys(nodes).length; i++){\n"
    txt += "            var node = new Object();\n"
    txt += "            node.id = nodes[i].id;\n"
    txt += "            node.color = nodes[i].style.background;\n"
    txt += "            output.n.push(node);\n"
    txt += "        }\n"
    txt += "        output.m = new Array();\n"
    txt += "        //Aggiungo archi all'output\n"
    txt += "        for(i=0; i < Object.keys(_lines).length; i++){\n"
    txt += "            var edge = new Object();\n"
    txt += "            edge.left = _lines[i].left_node;\n"
    txt += "            edge.right = _lines[i].right_node;\n"
    txt += "            edge.color = _lines[i].col;\n"
    txt += "            edge.orientation = _lines[i].gtype;\n"
    txt += "            edge.value = _lines[i].text;\n"
    txt += "            output.m.push(edge);\n"
    txt += "           }\n" 
    txt += "        var jsonString = JSON.stringify(output, null, '\t');\n"
    txt += "        window.parent.postMessage(jsonString, '*');\n"
    txt += "        refresh_edges();\n"
    txt += "    }\n\n"
    txt += "    function get_colored_nodes(){\n"
    txt += "        var output = new Object();\n"
    txt += "        output.nodes =  new Array();\n"
    txt += "        var nodes = document.getElementsByClassName('node');\n"
    txt += "        //Aggiungo nodi all'output\n"
    txt += "        for(i=0; i<Object.keys(nodes).length; i++){\n"
    txt += "            if(nodes[i].style.background != 'green'){\n"
    txt += "                var node = new Object();\n"
    txt += "                node = nodes[i].id;\n"
    txt += "                output.nodes.push(node);\n"
    txt += "            }\n"
    txt += "        }\n"
    txt += "        var jsonString = JSON.stringify(output, null);\n"
    txt += "        window.parent.postMessage(jsonString, '*');\n"
    txt += "    }\n\n"
    txt += "    function get_path(){\n"
    txt += "        var output = new Object();\n"
    txt += "        output.edges =  new Array();\n"
    txt += "        //Aggiungo archi all'output\n"
    txt += "        for(i=0; i < Object.keys(_lines).length; i++){\n"
    txt += "            if(_lines[i].col != 'black'){\n"
    txt += "                var edge = new Object();\n"
    txt += "                edge.left = _lines[i].left_node;\n"
    txt += "                edge.right = _lines[i].right_node;\n"
    txt += "                edge.orientation = _lines[i].gtype;\n"
    txt += "                edge.value = _lines[i].text;\n"
    txt += "                output.edges.push(edge);\n"
    txt += "                }\n"
    txt +=  "       }\n"
    txt += "    var jsonString = JSON.stringify(output, null, '\t');\n"
    txt += "    window.parent.postMessage(jsonString, '*');\n"
    txt += "    refresh_edges();\n"
    txt += "    }\n\n"
    txt += "    //Comunicazione parent-iframe\n"
    txt += "    window.onmessage = function(e){\n"
    txt += "        if (e.data == 'changecolor')\n"
    txt += "            path_color();\n"
    txt += "        if (e.data == 'edgeset')\n"
    txt += "            get_path();\n"
    txt += "        if (e.data == 'nodeset')\n"
    txt += "            get_colored_nodes();\n"
    txt += "        if (e.data == 'send')\n"
    txt += "            send_output();\n"
    txt += "    };\n"
    txt += "</script>"
    with open(os.path.join(os.getcwd(),"esame","templates","esame","graph.html"),"r") as stream:
        html = "".join(stream.readlines())
        t = html.replace("GRAFO",txt)
    
    f = open(os.path.join(TEMPLATES_DIRECTORY,"grafo_template.html"),"w")
    f.write(t)
    f.close()

    
    
    
